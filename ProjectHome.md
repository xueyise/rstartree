# R\*Tree算法实现 #

![http://rstartree.googlecode.com/files/image001.png](http://rstartree.googlecode.com/files/image001.png)

## <font color='#08088A'>实验内容</font> ##

本实验实现了R树和R\*树的空间索引结构。R树是利用多个维中的区间来表示数据对象的，它是一种高度平衡的树，由中间节点和页节点组成，实际数据对象的最小外接矩形存储在页节点中，中间节点通过聚集其低层节点的外接矩形形成，包含所有这些外接矩形。而在操作上则是基于在每一个内部节点中封闭矩形的面积的启发式优化。而R\*树则是R树的一个改进，在构造算法上，R\*树不仅考虑了索引空间的“面积”，而且还考虑了索引空间的重叠。该方法对结点的插入、分裂算法进行了改进，并采用“强制重新插入”的方法使树的结构得到优化。

**本次实验，我们不仅实现了R树和R\*树，并提供了其对应的数据接口。在指定数据的矩形区域的前提下，用户可以自行指定所插入数据类型，包括点、矩形等等，并且，所插入的数据可以是任意维度，这就是所谓的多维空间搜索。同时支持动态的增加、删除数据，提高操作上的便利性。**

## <font color='#08088A'>算法原理</font> ##

### <font color='#045FB4'>R树算法原理</font> ###

#### <font color='#0174DF'>R树基本结构</font> ####

R树是高度平衡的树，在其叶节点的索引记录中包含指向数据对象的指针。对于R树的叶子节点，其包含索引记录的条目，基本形式为(I, 元组标示符)，其中元祖标示符指向对应的数据，而I则是一个包含在一个边界盒内的空间对象的n维矩形，表示为：

_**I=(I<sub>0</sub>, I<sub>1</sub>, I<sub>2</sub>, ... I<sub>n-1</sub>)**_

其中n是指维度的个数， 是一个封闭的有界区间[a, b]，_**I<sub>i</sub>**用来描述在维度i上的空间对象的范围，_**I<sub>i</sub>**可以有一个或两个边界都是无穷大的，表面对象是无穷大的。R树的非叶子节点则包含了形如(I, child-pointer)的条目，这里child-pointer是一个低级节点在R树中的地址，而I覆盖了所有低级节点条目中的矩形。简单来讲，即每个节点包含了多个子节点或数据（当节点为叶子时），而节点中又包含了多维矩形I表示所有子节点或数据的最小包围矩形。
简单的一个R树结构如下图：

![http://rstartree.googlecode.com/files/image003.jpg](http://rstartree.googlecode.com/files/image003.jpg)

#### <font color='#0174DF'>R树性质</font> ####

R树有两个重要属性：M和m。其中M表示一个节点中条目的最大数量，而m小于等于M/2，表示一个节点中条目的最小数量。一个R树则具有下列性质：
  * 每个叶节点若不是根节点，则包含m至M个索引记录。
  * 叶节点中的每一个索引记录(I, 元组标示符)，I是在空间上包含n维数据对象的最小的矩形，该对象是由相应的元组给出的。
  * 每个非叶节点若不是根节点则有m至M个子节点。
  * 对于一个非叶节点中的条目(I, child-pointer)，I是在空间上包含在子节点中的矩形的最小矩形。
  * 根节点若果不是一个叶子，则至少有两个子节点。
  * 所有的叶子都位于同一层上
上图给出了R树的结构，并举例说明了其矩形间的包含及覆盖关系。
含有N挑索引记录的R树的高度最大是 ，这是因为每个节点的分支至少是m。所以节点的最大数目就是 ，出了根节点外，所有节点都是m时，空间的利用是最差的。节点含有多于m个条目时，将降低树的高度，提高空间利用率。如果节点有多于3个或4个条目的话，树就会变得很宽，几乎所有的空间多用于包含索引记录的叶节点。参数m可以调整，取不同的值。

#### <font color='#0174DF'>R树算法</font> ####

这里用EI表示索引条目E的矩形，用EP表示元组标识符或child-pointer。

#### 搜索算法Search ####
> 给定一棵R树，其根节点是T，输入参数为需要搜索的矩形S，找出其矩形覆盖S的所有索引记录。
  * [搜索子树]如果T不是叶子，检查每一个条目E，判断是否EI与S相交。对于所有相交的条目，在由EP指向的子树的根节点上调用Search
  * [搜索叶节点]如果T是一个叶子，检查所有EI判断是否覆盖S，若是，则E就是一个呵护要求的记录

#### 插入算法Insert ####
> 把一个新的索引条目E插入一个R树中。
  * [找到新纪录的位置]调用Choose Leaf选择一个叶节点L存放E。
  * [把记录加入到叶节点中]如果L有空间存放额外的条目，加入E；否则调用Split Node以获得包含E及所有原来L的条目L及LL。
  * [向上传递变化]在L上调用Adjust Tree，若完成了分裂，则也调整了LL。
  * [把树变高]如果节点分裂导致根节点的分裂，则生成一个新的根节点，其子节点为两个已有的节点


#### 算法Choose Leaf ####
> 选择一个叶节点来存放一个新的索引条目E。
  * [初始化]设N为根节点。
  * [检查叶子]如果N是叶子，返回N。
  * [选择子树]如果N不是叶子，设F为N中条目，它的矩形FI需要至少放大到包含了EI。通过选择有最小区域的矩形的条目来重新连接。
  * [向下进行直至到达一个叶子]设N为由FP指向的一个子节点，并从第2步处重复此过程。

#### 算法Adjust Tree ####
> 从一个叶节点L点上升到根，调整覆盖的矩形，需要则传递分裂。
  * [初始化]令N=L，如果L前面分裂过，设NN为所得的第二个节点。
  * [检查是否完成]如果N为根，则停止。
  * [调整在父条目中覆盖的矩形]令P作为N的父节点，令EN作为N在P中的条目，调整ENI，使其紧密地围住N中全部的条目矩形。
  * [向上传递节点分裂]如果N有一个伙伴——从早先分裂中得到的NN，则生成一个新的条目ENN，并用ENNP指向NN，而ENNI围住所有NN中的矩形。若还有空间，则把ENN加入P中。否则调用Split Node来生成P、PP、ENN及P中的所有条目。
  * [移动到下一层]令N=P，如果出现一个分裂令NN=PP，从第2步重复。

#### 算法Delete ####
> 从R树中删除索引记录E。
  * [找到包含记录的节点]调用Find Leaf找到包含E的叶节点L，若果没有找到记录则停止。
  * [删除记录]从L中删除E。
  * [传递变化]调用Condense Tree，经过L。
  * [降低书]如果根节点在经过树的调整之后仅有一个子节点，将这个子节点作为新的根节点。

#### 算法Find Leaf ####
> 给定一棵R树，其根节点为T，找出所有包含索引条目E的叶节点。
  * [搜索子树]如果T不是叶子，检查T中的每个条目F，判断是否FI覆盖了EI。针对每个这样的条目，在由FP指向的树中的根节点上调用Find Leaf，直至E被找到或者所有的条目都被检查过。
  * [搜索记录的叶节点]如果T是一个叶子，检查每个条目，看其是否与E匹配，若找到E则返回T。

#### 算法Condense Tree ####
> 给定一个叶节点，其中已删除一个条目，如果它有很少的条目，则消除节点，并转移其条目。若有需要，则向上传递的节点消除。调整到达根的路径上所有覆盖的矩形，如果可能，则使他们变得更小。
  * [开始]令N=L，设Q为一组消除的节点，置为空。
  * [找到父条目]如果N为根，转移到第6步，否则令P为N的父节点，令EN为N在P中的条目。
  * [消除不饱和的节点]若N中有少于m个条目，从P中删除EN，把N加入到Q中。
  * [调整覆盖的矩形]若N未被消除，调整ENI，使其包含N中的所有条目。
  * [向上移动一层]令N=P，从第2步重复进行。
  * [重新插入孤立的条目]重新插入所有Q中节点的条目。将消除的叶节点中的条目重新插入到树的叶节点上，插入算法见算法Insert。但在高一层的节点上条目必须放置在树的高层上，这样它们独立的子树上的叶子可以在同一层上，就像主树上的叶子一样。

#### 节点分裂 ####
> 为了在一个以包含M个条目的已满的节点中加入一个新的条目，把M+1个条目的集合分成两个节点是必须的。这个分配应按下述方法进行，尽量使两个新节点在接下来的搜索检查中不同时出现。因为访问一个节点取决于其覆盖的矩形所覆盖的搜索面积。两个覆盖矩形的总面积在一个分裂之后应为最小。图2举例说明了这点。不良分裂的覆盖矩形面积要比最佳情况下的面积大的多。

![http://rstartree.googlecode.com/files/image011%20-%20%E5%89%AF%E6%9C%AC.png](http://rstartree.googlecode.com/files/image011%20-%20%E5%89%AF%E6%9C%AC.png)

#### 二次方代价算法 ####
> 这个算法是为了找到一个最小面积的分裂，但无法保证一定会找到这个最小面积。代价是M的二次方并且与维数成线性关系。算法首先从M+1个条目中选出两个条目作为两个新组中的第一个成员，选择这两个条目的方法是若两个条目放在同一组内将浪费的面积最大，即覆盖了两个条目的矩形面积减去两个条目的面积最大的。剩余的条目每次分配就是使两个差别最大的那个条目。

#### 算法Quadratic Split ####
> 把M+1个索引条目分成两组。
  * [从每个组中取第一个条目]调用算法Pick Seeds选出两个条目作为两组中的第一个成员，分配到组中。
  * [检查是否结束]若所有的条目都被分配，则停止；若一组中条目很少，则剩余的条目必须分配到这组中，来保证其条目数量达到最小值m，分配之后停止。
  * [选择待分配的条目]调用算法Pick Next选择下一个待分配的条目。把它加入到所覆盖矩形在进行最小扩展就可容纳它的组中。将条目加入到哪个组中的方案为：首先考虑面积较小的组，其次是条目较少的组，最后是其他条件。从第2步重复。

#### 算法Pick Seeds ####
> 选择两个条目作为组中的新成员。
  * [计算两个条目的面积对应值]对每一对条目E1及E2组成一个包括E1I及E2I的矩形J，计算d=area(J)-area(E1I)-are(E2I)。
  * [选择浪费最大的对]选择d最大的一对条目返回。

#### 算法Pick Next ####
> 从余下的条目中选出一个防盗组中。
  * [判断把一个条目放入一个组中的代价]对还未放入组中的每个条目E，计算d1=第一组包含EI后覆盖矩形增加的买年纪，类似地计算第二组d2。
  * [找到对于每个组的最佳条目]选择d1与d2最大差别的条目。

### <font color='#045FB4'>R*树算法原理</font> ###

R\*树是对R树的改进，在稍微增加建树时间的基础上，大大提高了查询效率。其主要在以下三个部分对R树进行了改进。

#### <font color='#0174DF'>Choose Subtree算法</font> ####

为了解决选择一个合适的插入路径的问题，R树的描述中仅考虑面积参数。在R\*树的描述中将对面积、边缘及覆盖组合起来考虑，其中一个条目的覆盖定义如下：

![http://rstartree.googlecode.com/files/image014.gif](http://rstartree.googlecode.com/files/image014.gif)

下面是具有最佳查询性能的算法。

#### Choose Subtree算法 ####
  * 令N为根节点。
  * if N是一个叶子。

> return N

> else

> if N中子节点指针不指向叶子，[确定最小面积耗费]选择N中的条目，该条目需要最小的面积扩展以包含新数据的矩形，选择其矩形需要的最小区域扩展的条目来继续下一步查询。

> then 选择条目具有最小面积的矩形。

> if N中的孩子的指针不指向叶子，[确定最小覆盖代价]选择N中的条目，该条目需要最小的覆盖扩展以包含新数据的矩形，选择其矩形需要的最小覆盖扩展来继续查询数据。

  * 设N为所选择出的条目的子指针所指向的子节点，转到第2步重复执行

对于选择最佳非叶节点，R\*树的算法并不优于Guttman的原始算法。然而对于叶节点，使用覆盖最小扩展在性能方面则会更好一些。

在该算法中，决定覆盖的CPU的运算量是条目数目的平方量级，因为对于每个条目，与节点中其他条目的覆盖均是需要计算的，但对于大容量的节点，可以减少必须进行计算的条目数量。可以这样认为，对于距离较远的矩形，产生最小覆盖的可能性极小，因此为了降低CPU的运算量，这部分算法可以修改成如下算法：

#### 确定最近似的最小覆盖算法 ####
  * 将N中的矩形排序，按其需要包含新数据的矩形面积扩展量的升序排列。
  * 设A代表排序后前p个条目，仅对A中的条目进行处理，来代替处理N中的所有条目，选择其矩形需要最小覆盖扩展的条目来进行查询。如果出现相等情况，则选择扩展矩形较小的节点继续查询。

在二维的情况下，把p设为32通常就不会降低查询操作的性能。

#### <font color='#0174DF'>R*树的分裂</font> ####

#### 算法Split ####

输入：要分裂的节点的指针

输出：指向分裂后两个节点的指针

Step.1 调用ChooseSplitAxis算法选择要分裂的坐标轴（维度）splitAxis

Step.2 在选择好的维度上调用ChooseSplitIndex算法，算法结束后返回两个值：bool minOrMax:标识最终的分裂是在哪个排序结果上；int splitIndex:将某个排序进行分裂的分界点，对与由minOrMax所确定的

#### 算法ChooseSplitAxis ####
输入：要分裂的节点
输出：要分裂的维度，范围为0～d-1，其中d为R树中数据的维度。
Step.1 将当前维度置为0，将最佳分裂维度设置为0，转到Step.2
Step.2 如果当前维度已经超过d-1，返回当前的最佳分裂维度.
> 否则，在当前维度上对分裂节点的所有子节点做两组排序
> 第一组排序根据当前维度区间的下届，从小到大
> 第二组排序根据当前维度区间的上界，从小到大
> 对于两组排序中的任何一组，我们都可以将其分裂两个部分，第一个部分包括前m-1+k个子节点，另外一部分M+2-m-k个子节点。其中k的范围是1到M-2×m+2。
> 对于两组排序，都可以按以上方案分裂成两个节点，S1和S2，对于全部两个排序下的全部分裂方案，都计算S1和S2的margin之和margin(S1)+margin(S2)，并将其累加。
> margin指的是各个维度的区间长度之和。
> 对于当前维度，我们都可以得到一个margin的总和，如果该总和与以前维度所计算出来的总和相比更小，则将当前维度设置为最佳分裂维度。
> 将当前维度加1，重复执行Step2.

#### 算法ChooseSplitIndex ####

输入：要分裂的节点和最佳分裂维度

输出：最佳分裂排序，最佳分裂点

算法过程：

> 在最佳分裂维度上，对分裂节点的所有子节点做两组排序

> 第一组排序根据当前维度区间的下届，从小到大

> 第二组排序根据当前维度区间的上界，从小到大

> 对于两组排序中的任何一组，我们都可以将其分裂两个部分，第一个部分包括前m-1+k个子节点，另外一部分M+2-m-k个子节点。其中k的范围是1到M-2×m+2。

> 对两组排序，都可以按以上方案分裂成两个节点S1和S2，计算S1和S2区域的重叠部分的面积（如果是2维的话）。

> 对于所有的分裂方案，选择重叠面积最小的分裂方案，如果发生重叠面积相同的情况，则选择S1和S2面积之和(如果是2维的话)最小的一个，如果两个分裂方案面积之和也出现相		同情况，可以选择两种方案中的任何一个。

> 对于最佳分裂方案，返回其所在的排序分组以及分裂点。

#### <font color='#0174DF'>强迫重插入</font> ####

在分配条目入节点时，R树和R\*树都是不确定的，既不同的插入会建成不同的树。因为这个原因，R树受制于它的旧条目。数据矩形插入在早期的结构生成时会产生固定的矩形，其不能保证当前情况下好的查询操作。一个对有限制性的固定矩形的调整是在一个分裂过程中执行的，但这一过程效率不高，因此我们需要一个更有力且少限制性的调整方法。

为了得到一个有力的调整，R\*树在常规插入时，进行强迫重插入操作。下列的算法即是基于树的同层插入记录的常规插入及删除算法，它与原始的Guttman算法很相似，但这只是一个简单草案。

#### Insert Data算法 ####
  * 调用insert作为参数，从叶子层开始，插入一个新的数据矩形。

#### Insert算法 ####
  * 调用Choose Subtree，以层作为参数，找到一个合适的点N，插入新条目E。
  * 如果N中有少于M条条目，把E插入N，如果N中有M条条目，以N层作为参数，调用Overflow Treatment[重插入或分割操作]。
  * 如果Overflow Treatment被调用，而且执行了一次分裂，如果需要，把Overflow Treatment向上传递，如果Overflow Treatment导致根节点的分裂，就重建一个根节点，树高度加一。
  * 调节所有在插入路径上被覆盖的矩形，这一，它们的矩形就是最小的封闭它们孩子们的矩形。

#### Overflow Treatment算法 ####
  * 在插入一个数据矩形的过程中，如果不是根节点层，且是在给定层的第一次调用该算法，则调用Re Insert，否则调用Split算法。

#### Re Insert算法 ####
  * 对于一个节点N中的所有M+1条条目，分别计算它们矩形中心到N的矩形中心的距离。
  * 按距离降序排列这些节点。
  * 去掉N中的前p条条目，调整N的矩形大小。
  * 按第2步的顺序，以距离最大值开始调用Insert算法来重新插入P条条目。（这里同样可以按距离最小值插入，删除掉P个距离最小的节点，然后从小到大插入）

可以总结如下：
  1. 强迫重插入在相邻节点间改变条目，因此降低了重叠。
  1. 作为一方面的影响，提高了存储利用率。
  1. 对于更多的调整，分裂较少。
  1. 一个节点的远离中心的矩形被重新插入，节点矩形区域会减小，更加利于查询。

## <font color='#08088A'>程序框架</font> ##

### <font color='#045FB4'>类图</font> ###

![http://rstartree.googlecode.com/files/image016.gif](http://rstartree.googlecode.com/files/image016.gif)

### <font color='#045FB4'>数据结构</font> ###

#### 区间结构 ####
```
struct RSTInter 
{
public:
	double min;// 区间下界
	double max;// 区间上界
}
```

#### 多维区间集合 ####
```
typedef std::vector<RSTInter> RSTRange;// 表示多维区间，为区间的集合，可以用于表示高维矩形
```

#### 节点定义 ####
```
class RSTNode
{
public:
	int type;// 节点类型，包括叶子节点、非叶子节点和数据节点
	RSTNode* parent;// 父节点指针
	RSTRange range;// 记录矩形区域
	int childNum;// 子节点个数	
RSTNode** childSet;// 子节点指针，为指针动态数组
}
```

#### 节点集合 ####
```
typedef vector<RSTNode*> RSTNodeSet; // 节点集合，用于记录一系列节点
```

#### 点定义 ####
```
typedef vector<double> RSTCPoint;// 点定义，用于记录多维点
```

#### R树结构 ####
```
class RSTRTree
{
public:
	int height;// 树的高度，从跟开始到叶子节点的高度，只有一个根时高度为
	int dim;// 树的维度
	RSTNode* Root;// 树的根节点

	int m;// 子节点的最小数目
	int M;// 子节点的最大数目
}
```

#### R\*树结构 ####
```
class RSTRStarTree : public RSTRTree// 继承了R树结构
{
}
```

### <font color='#045FB4'>文件说明</font> ###

主要的算法文件包括以下一些文件：
  1. RSTDefine.h，RSTBasisFunction.cpp，定义了一些基本数据结构，包括节点结构、区间结构等，实现了节点和区间的基本操作。同时也包括其他的一些常量值、集合的定义和相关方法的实现。
  1. RSTRTree.h，RSTRTree.cpp，定义了R树和R\*树的算法实现，包括树结构定义和具体的算法实现。
  1. RSTTestData.h，RSTTestData.cpp，定义了一些用于测试的数据结构，包括二维点、矩形及多维点、矩形。

## <font color='#08088A'>实验结果</font> ##

### <font color='#045FB4'>建树时间比较</font> ###

下面给出了m与M分别取不同值时的建树时间，其中数据均为二维点形式。

![http://rstartree.googlecode.com/files/table11.png](http://rstartree.googlecode.com/files/table11.png)

![http://rstartree.googlecode.com/files/table12.png](http://rstartree.googlecode.com/files/table12.png)

![http://rstartree.googlecode.com/files/table13.png](http://rstartree.googlecode.com/files/table13.png)

![http://rstartree.googlecode.com/files/table14.png](http://rstartree.googlecode.com/files/table14.png)

### <font color='#045FB4'>查询时间比较</font> ###

下面给出了m和M取不同值时的R树和R\*树的查询时间比较。数据为二维的点。在给定点数的情况下，每次进行十次随机查询，表格中的数据为这十次查询时间的平均值。


![http://rstartree.googlecode.com/files/table21.png](http://rstartree.googlecode.com/files/table21.png)

![http://rstartree.googlecode.com/files/table22.png](http://rstartree.googlecode.com/files/table22.png)

![http://rstartree.googlecode.com/files/table23.png](http://rstartree.googlecode.com/files/table23.png)

![http://rstartree.googlecode.com/files/table24.png](http://rstartree.googlecode.com/files/table24.png)

## <font color='#08088A'>显示说明</font> ##

我们的R树和R\*树理论上可以应用于任意维度的数据，但是多维数据的可视化比较抽象和难以看懂，这里只实现了对二维数据的三维显示。

目前支持显示的数据类型有二维点和二维矩形，如果用户想显示自己定义的二维数据，需要继承RSTNode这个类，并实现几个必要的函数，具体可以参考“RSTTestData.h”中RSTPoint2D类的写法。

与显示相关的类主要有两个：一个是MyGLShow3D类，封装了最底层的OpenGL视图控制操作，这个类与数据无关，可以移植到其他希望通过MFC框架实现OpenGL三维显示的工程中。另一个类是Tree2DShow3D类，这个类封装了显示二维R和R\*树所需的辅助变量和操作，它是在R树的上层建立起来的，不会对R树的实现和应用产生任何影响，如果用户希望单独使用R树，可以将R树部分的代码单独分离出来使用。

## <font color='#08088A'>总结</font> ##

本次实验主要进行了一种多维查找结构R-Tree以及其重要变种R\*Tree的实现以及测试。R-Tree不仅在计算几何上有所应用，在空间数据库索引和GIS系统中也有着广泛的应用，一方面，该结构吸收了B树的优点，另一方面，有弥补了k-d树和Range树静态建树而不能动态插入和删除节点的不足。

本次实验针对二维点数据和二维矩形进行了R树和R\*树的演示，演示内容包括树的直观表示，查找过程的进行等等，并提供手动加入二维点数据或矩形数据以及删除数据等功能，为R树的用户提供了R树的直观表示，加深其对R树的理解和使用。对于任意维度的数据，我们规范了R树的使用接口，实现了数据处理与用户数据实现相分离。

另外对R树和R\*树的性能我们在实验中也做了充分测试，实验结果表明虽然R\*的插入过程和节点分裂过程更加复杂，但其查询效率明显高于R树。

本实验将演示程序和R树的定义接口整合在了同一个工程中，如果单独使用请将R树的实现部分单独分离出来进行使用。

## <font color='#08088A'>参考文献</font> ##

  * A Guttman ‘R-trees a dynamic mdex structure for spatial searching’, Proc ACM SIGMOD Int Conf on Management of Data, 47-57, 1984.
  * BeckmannN ., KriegelH .-P.,S chneideRr , andS eegeBr . 1990. The R**-tree: An Efficient and Robust Access Method for Points and Rectangles, Proc. ACM SIGMOD Int. Conf. on Management of Data, Atlantic City, NJ, 1990, pp. 322-331.**

## <font color='#08088A'>附录</font> ##

### 输入数据格式 ###

![http://rstartree.googlecode.com/files/image015.jpg](http://rstartree.googlecode.com/files/image015.jpg)

文件首行是必须关键字：“testdata2d”。如果首行没有这个关键字，程序会报告“格式错误”。

接下来是各个数据的个数，目前只支持两种数据类型，一种是2维点，另一种是2维矩形。例如上图，输入3个点，和3个矩形，首先写“pointnumber：”，然后换行，然后写对应的数目“3”。换行，写“rectanglenumber：”，换行，写对应的数目“3”。可以调换点和矩形的输入顺序，也可以只写其中一种。

接下来由关键字“databegin”标记数据段开始。

接下来由关键字“pointdata”或“rectangledata”来标记数据的类型，数据类型后接坐标值。同一个数据的坐标值之间以“空格”分隔，不同的数据的坐标之间以“换行”分隔。

对于2维点，第一个数是x坐标值，第二个数是y坐标值。

对于2维矩形，第一个数是矩形左下角的x坐标，第二数是左下角的y坐标，第三个点是右上角的x坐标，第四个点是右上角的y坐标。如果输入的坐标顺序有错，那么程序计算出的结果将不正确。

最后由关键字“dataend”标记数据段结束。

输入数据的拓展名是“.txt”，这样做是为了查看和编辑数据方便，在手工编辑数据的时候有两点非常需要注意：1，前面声明数据的数目和后面真实的数据数目要一致，比如前面声明有3个点，那么后面必须有3个点的坐标，否则程序可能出现错误。2，尽量不要有空行，否则程序也可能出现错误。